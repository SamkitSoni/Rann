/**
 * Authentication Routes
 * 
 * Wallet-based authentication endpoints with JWT tokens
 * 
 * @author Rann Team
 */

import { Router } from 'express';
import type { Response } from 'express';
import type { AuthenticatedRequest } from '../types/index';
import { 
  verifySignature, 
  requireAuth, 
  generateAuthMessage, 
  generateToken 
} from '../middleware/auth';
import { asyncHandler } from '../middleware/errorHandler';

/**
 * Create authentication routes
 */
export function createAuthRoutes(): Router {
  const router = Router();

  /**
   * POST /api/auth/nonce
   * Generate authentication nonce for wallet signing
   */
  router.post('/nonce', asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      const { address } = req.body as { address?: string };

      if (!address) {
        res.status(400).json({
          success: false,
          message: 'Wallet address is required',
          timestamp: new Date().toISOString()
        });
        return;
      }

      // Validate address format
      if (!req.services.crypto.isValidAddress(address)) {
        res.status(400).json({
          success: false,
          message: 'Invalid wallet address format',
          timestamp: new Date().toISOString()
        });
        return;
      }

      const authMessage = generateAuthMessage();
      
      // Store nonce temporarily (expires in 5 minutes)
      await req.services.database.storeUserSession(address, {
        nonce: authMessage.nonce,
        timestamp: authMessage.timestamp,
        expires: Date.now() + (5 * 60 * 1000) // 5 minutes
      });

      res.json({
        success: true,
        data: {
          message: authMessage.message,
          nonce: authMessage.nonce,
          timestamp: authMessage.timestamp
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Nonce generation failed:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to generate authentication nonce',
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * POST /api/auth/login
   * Authenticate with wallet signature
   */
  router.post('/login', verifySignature, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      const address = req.verifiedAddress!;
      const messageData = req.messageData!;

      // Verify nonce was generated by our system
      const session = await req.services.database.getUserSession(address);
      
      if (!session || session.sessionData.nonce !== messageData.nonce) {
        res.status(401).json({
          success: false,
          message: 'Invalid nonce. Please request a new one.',
          timestamp: new Date().toISOString()
        });
        return;
      }

      // Check if nonce has expired
      if (Date.now() > session.sessionData.expires) {
        res.status(401).json({
          success: false,
          message: 'Nonce expired. Please request a new one.',
          timestamp: new Date().toISOString()
        });
        return;
      }

      // Generate JWT token
      const token = generateToken(address, {
        loginTime: new Date(),
        userAgent: req.get('User-Agent'),
        ip: req.ip
      });

      // Store session data
      await req.services.database.storeUserSession(address, {
        token,
        loginTime: new Date(),
        lastActive: new Date(),
        userAgent: req.get('User-Agent'),
        ip: req.ip
      });

      // Set cookie and return token
      res.cookie('auth_token', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.json({
        success: true,
        data: {
          token,
          address,
          expiresIn: '7d'
        },
        message: 'Authentication successful',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Login failed:', error);
      res.status(500).json({
        success: false,
        message: 'Authentication failed',
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * POST /api/auth/logout
   * Logout and invalidate session
   */
  router.post('/logout', requireAuth, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      const address = req.user!.address;

      // Clear session from database
      await req.services.database.deleteUserSession(address);

      // Clear cookie
      res.clearCookie('auth_token');

      res.json({
        success: true,
        message: 'Logout successful',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Logout failed:', error);
      res.status(500).json({
        success: false,
        message: 'Logout failed',
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * GET /api/auth/profile
   * Get current user profile
   */
  router.get('/profile', requireAuth, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      const address = req.user!.address;
      const session = req.user!.sessionData;

      // Get user's Yodhas
      const yodhas = await req.services.database.getUserYodhas(address);
      
      // Get battle stats
      const battleStats = yodhas.length > 0 ? 
        await req.services.database.getBattleStats(yodhas[0].tokenId) : 
        { totalBattles: 0, wins: 0, losses: 0, winRate: 0 };

      // Get active training sessions
      const activeTraining = await req.services.database.getActiveTrainingSessions();
      const userTraining = activeTraining.filter(training => 
        yodhas.some(yodha => yodha.tokenId === training.tokenId)
      );

      res.json({
        success: true,
        data: {
          address,
          sessionInfo: {
            loginTime: session.loginTime,
            lastActive: session.lastActive,
            userAgent: session.userAgent
          },
          yodhas: yodhas.length,
          battleStats,
          activeTraining: userTraining.length
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Profile fetch failed:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch profile',
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * POST /api/auth/refresh
   * Refresh JWT token
   */
  router.post('/refresh', requireAuth, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      const address = req.user!.address;

      // Generate new token
      const newToken = generateToken(address, {
        refreshTime: new Date(),
        userAgent: req.get('User-Agent'),
        ip: req.ip
      });

      // Update session
      await req.services.database.storeUserSession(address, {
        ...req.user!.sessionData,
        token: newToken,
        refreshTime: new Date(),
        lastActive: new Date()
      });

      // Set new cookie
      res.cookie('auth_token', newToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
      });

      res.json({
        success: true,
        data: {
          token: newToken,
          expiresIn: '7d'
        },
        message: 'Token refreshed successfully',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Token refresh failed:', error);
      res.status(500).json({
        success: false,
        message: 'Token refresh failed',
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * GET /api/auth/sessions
   * Get active sessions (admin only)
   */
  router.get('/sessions', requireAuth, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      // This would typically require admin access
      // For now, just return user's own session
      const address = req.user!.address;
      const session = await req.services.database.getUserSession(address);

      if (!session) {
        res.status(404).json({
          success: false,
          message: 'Session not found',
          timestamp: new Date().toISOString()
        });
        return;
      }

      res.json({
        success: true,
        data: {
          address: session.address,
          lastActive: session.lastActive,
          createdAt: session.createdAt
        },
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Sessions fetch failed:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch sessions',
        timestamp: new Date().toISOString()
      });
    }
  }));

  /**
   * POST /api/auth/verify
   * Verify JWT token validity
   */
  router.post('/verify', requireAuth, asyncHandler(async (req: AuthenticatedRequest, res: Response) => {
    try {
      // If we reach here, the token is valid (passed requireAuth middleware)
      res.json({
        success: true,
        data: {
          valid: true,
          address: req.user!.address,
          sessionId: req.user!.sessionId
        },
        message: 'Token is valid',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      console.error('❌ Token verification failed:', error);
      res.status(500).json({
        success: false,
        message: 'Token verification failed',
        timestamp: new Date().toISOString()
      });
    }
  }));

  return router;
}

export default createAuthRoutes;
