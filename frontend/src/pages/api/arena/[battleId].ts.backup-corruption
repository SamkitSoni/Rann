// API endpoints for arena automation
import { NextApiRequest, NextApiResponse } from 'next';
import { createWalletClient, http, createPublicClient, keccak256, encodePacked } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { defineChain } from 'viem';
import { KurukshetraAbi, KurukshetraFactoryAbi, chainsToTSender } from '../../../constants';

// Define Flow EVM chains
const flowTestnet = defineChain({
  id: 545,
  name: 'Flow Testnet',
  network: 'flow-testnet',
  nativeCurrency: {
    decimals: 18,
    name: 'Flow',
    symbol: 'FLOW',
  },
  rpcUrls: {
    default: {
      http: [process.env.FLOW_TESTNET_RPC || 'https://testnet.evm.nodes.onflow.org'],
    },
    public: {
      http: [process.env.FLOW_TESTNET_RPC || 'https://testnet.evm.nodes.onflow.org'],
    },
  },
  blockExplorers: {
    default: { name: 'Flow Testnet Explorer', url: 'https://evm-testnet.flowscan.org' },
  },
});

// In-memory storage for game state
const gameStates = new Map<string, any>();
const activeTimers = new Map<string, NodeJS.Timeout>();
const arenaAddressCache = new Map<string, string>();
const lastTransactionHashes = new Map<string, string>();

// Initialize clients
let walletClient: any = null;
let publicClient: any = null;

function initializeClients() {
  if (walletClient && publicClient) return { walletClient, publicClient };

  try {
    const chain = flowTestnet;
    const rpcUrl = process.env.FLOW_TESTNET_RPC || 'https://testnet.evm.nodes.onflow.org';

    publicClient = createPublicClient({
      chain,
      transport: http(rpcUrl)
    });

    const gameMasterPrivateKey = process.env.NEXT_PUBLIC_GAME_MASTER_PRIVATE_KEY;
    if (!gameMasterPrivateKey) {
      console.warn('Game master private key not found - automation will be simulation only');
      return { walletClient: null, publicClient };
    }

    const gameMasterAccount = privateKeyToAccount(
      gameMasterPrivateKey.startsWith('0x') 
        ? gameMasterPrivateKey as `0x${string}`
        : `0x${gameMasterPrivateKey}` as `0x${string}`
    );

    walletClient = createWalletClient({
      account: gameMasterAccount,
      chain,
      transport: http(rpcUrl)
    });

    console.log('‚úÖ Blockchain clients initialized successfully');
    return { walletClient, publicClient };
  } catch (error) {
    console.error('‚ùå Failed to initialize blockchain clients:', error);
    return { walletClient: null, publicClient: null };
  }
}

// Get contract address
async function getKurukshetraContractAddress(battleId: string): Promise<string | null> {
  // DIRECTLY USE BATTLEID AS CONTRACT ADDRESS - NO QUESTIONS ASKED
  console.log(`üìç Using battleId directly: ${battleId}`);
  return battleId;
}

  const { publicClient } = initializeClients();
  if (!publicClient) return null;

  try {
    const contracts = chainsToTSender[545];
    const factoryAddress = contracts.KurukshetraFactory;

    const arenas = await publicClient.readContract({
      address: factoryAddress as `0x${string}`,
      abi: KurukshetraFactoryAbi,
      functionName: 'getArenas',
      args: []
    }) as string[];

    const arenaIndex = parseInt(battleId) % arenas.length;
    const arenaAddress = arenas[arenaIndex] || arenas[0];
    
    if (arenaAddress) {
      arenaAddressCache.set(battleId, arenaAddress);
      console.log(`üìç Mapped battle ${battleId} to arena ${arenaAddress}`);
      return arenaAddress;
    }

    return null;
  } catch (error) {
    console.error('‚ùå Failed to get arena address:', error);
    return null;
  }
}

// Execute startGame transaction
async function executeStartGame(battleId: string): Promise<any> {
  console.log(`üéÆ Executing startGame for battle ${battleId}`);
  
  // Get the current state
  const state = gameStates.get(battleId);
  if (!state) {
    console.error('‚ùå Game state not found');
    return { success: false, error: 'Game state not found' };
  }
  
  // For simulation mode
  if (state.isSimulation) {
    console.log(`‚öôÔ∏è Simulating startGame for battle ${battleId}`);
    await new Promise(resolve => setTimeout(resolve, 1000));
    const hash = `sim-start-${Date.now()}`;
    
    // Critical: Update gameStarted flag
    state.gameStarted = true;
    console.log(`‚úÖ [Simulation] Game started for battle ${battleId}`);
    lastTransactionHashes.set(battleId, hash);
    gameStates.set(battleId, state);
    
    return { 
      success: true, 
      hash, 
      simulation: true 
    };
  }
  
  // Real blockchain interaction
  const { walletClient, publicClient } = initializeClients();
  if (!walletClient || !publicClient) {
    console.error('‚ùå Wallet client not available');
    return { success: false, error: 'Wallet client not available' };
  }
  
  try {
    const contractAddress = await getKurukshetraContractAddress(battleId);
    if (!contractAddress) {
      return { success: false, error: 'Contract address not found' };
    }
    
    console.log(`üöÄ Calling startGame() on ${contractAddress}`);
    
    const hash = await walletClient.writeContract({
      address: contractAddress as `0x${string}`,
      abi: KurukshetraAbi,
      functionName: 'startGame',
      args: []
    });
    
    console.log(`‚úÖ startGame transaction sent: ${hash}`);
    
    const receipt = await publicClient.waitForTransactionReceipt({
      hash: hash as `0x${string}`,
      timeout: 60000
    });
    
    if (receipt.status === 'success') {
      // Critical: Update gameStarted flag
      state.gameStarted = true;
      console.log(`‚úÖ Game started successfully for battle ${battleId}`);
      lastTransactionHashes.set(battleId, hash as string);
      gameStates.set(battleId, state);
      
      return { success: true, hash, receipt };
    } else {
      console.error(`‚ùå startGame transaction failed with status: ${receipt.status}`);
      return { success: false, error: `Transaction failed: ${receipt.status}` };
    }
  } catch (error) {
    console.error(`‚ùå Failed to execute startGame:`, error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Execute battle transaction with signature
async function executeBattle(battleId: string): Promise<any> {
  console.log(`‚öîÔ∏è Executing battle for battle ${battleId}`);
  
  // Get the current state
  const state = gameStates.get(battleId);
  if (!state) {
    console.error('‚ùå Game state not found');
    return { success: false, error: 'Game state not found' };
  }
  
  // For simulation mode
  if (state.isSimulation) {
    console.log(`‚öôÔ∏è Simulating battle for round ${state.currentRound}`);
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Generate random moves
    const move1 = Math.floor(Math.random() * 5);
    const move2 = Math.floor(Math.random() * 5);
    console.log(`üéÆ [Simulation] Moves: ${move1} vs ${move2}`);
    
    const hash = `sim-battle-${Date.now()}`;
    lastTransactionHashes.set(battleId, hash);
    
    // Update state
    state.lastMoves = { move1, move2 };
    state.lastVerified = true;
    gameStates.set(battleId, state);
    
    console.log(`‚úÖ [Simulation] Battle executed for round ${state.currentRound}`);
    
    return { 
      success: true, 
      hash, 
      simulation: true,
      moves: { move1, move2 }
    };
  }
  
  // Real blockchain interaction
  const { walletClient, publicClient } = initializeClients();
  if (!walletClient || !publicClient) {
    console.error('‚ùå Wallet client not available');
    return { success: false, error: 'Wallet client not available' };
  }
  
  try {
    const contractAddress = await getKurukshetraContractAddress(battleId);
    if (!contractAddress) {
      return { success: false, error: 'Contract address not found' };
    }
    
    // Generate random moves for AI
    const move1 = Math.floor(Math.random() * 5) as 0 | 1 | 2 | 3 | 4;
    const move2 = Math.floor(Math.random() * 5) as 0 | 1 | 2 | 3 | 4;
    
    console.log(`üéØ Moves: ${move1} vs ${move2}`);
    
    // FIXED: Create signature for the battle moves
    const encodedMoves = encodePacked(['uint8', 'uint8'], [move1, move2]);
    const dataHash = keccak256(encodedMoves);
    const ethSignedMessageHash = keccak256(
      encodePacked(['string', 'bytes32'], ['\x19Ethereum Signed Message:\n32', dataHash])
    );
    
    const signature = await walletClient.signMessage({
      message: { raw: ethSignedMessageHash }
    });
    
    console.log(`üöÄ Calling battle() on ${contractAddress}`);
    
    const hash = await walletClient.writeContract({
      address: contractAddress as `0x${string}`,
      abi: KurukshetraAbi,
      functionName: 'battle',
      args: [move1, move2, signature]
    });
    
    console.log(`‚úÖ battle transaction sent: ${hash}`);
    
    const receipt = await publicClient.waitForTransactionReceipt({
      hash: hash as `0x${string}`,
      timeout: 60000
    });
    
    if (receipt.status === 'success') {
      console.log(`‚úÖ Battle executed successfully for round ${state.currentRound}`);
      lastTransactionHashes.set(battleId, hash as string);
      state.lastMoves = { move1, move2 };
      state.lastVerified = true;
      gameStates.set(battleId, state);
      
      return { success: true, hash, receipt, moves: { move1, move2 } };
    } else {
      console.error(`‚ùå battle transaction failed with status: ${receipt.status}`);
      return { success: false, error: `Transaction failed: ${receipt.status}` };
    }
  } catch (error) {
    console.error(`‚ùå Failed to execute battle:`, error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Stop round timer
function stopTimer(battleId: string) {
  const timer = activeTimers.get(battleId);
  if (timer) {
    clearInterval(timer);
    activeTimers.delete(battleId);
    console.log(`‚èπÔ∏è Stopped timer for battle ${battleId}`);
  }
}

// Start timer with counter
function startTimer(battleId: string) {
  // Clear any existing timer
  stopTimer(battleId);
  
  console.log(`‚è∞ Starting timer for battle ${battleId}`);
  
  const timer = setInterval(() => {
    // Get current state
    const state = gameStates.get(battleId);
    if (!state) {
      console.log(`‚ö†Ô∏è Battle ${battleId} not found, stopping timer`);
      stopTimer(battleId);
      return;
    }
    
    // Check if game is finished or paused
    if (state.gameState === 'finished' || state.gameState === 'paused') {
      console.log(`üõë Battle ${battleId} is ${state.gameState}, stopping timer`);
      stopTimer(battleId);
      return;
    }
    
    // Update countdown
    state.timeRemaining = Math.max(0, state.timeRemaining - 1);
    state.lastUpdate = Date.now();
    
    // Log every 10 seconds or when timeRemaining <= 10
    if (state.timeRemaining % 10 === 0 || state.timeRemaining <= 10) {
      console.log(`‚è±Ô∏è Battle ${battleId}: ${state.timeRemaining}s remaining (Round ${state.currentRound})`);
    }
    
    // Save updated state
    gameStates.set(battleId, state);
    
    // Check if timer has reached zero
    if (state.timeRemaining === 0) {
      handleTimerExpiration(battleId);
    }
  }, 1000);
  
  activeTimers.set(battleId, timer);
}

// Handle timer expiration
async function handleTimerExpiration(battleId: string) {
  console.log(`‚è∞ Timer expired for battle ${battleId}`);
  
  const state = gameStates.get(battleId);
  if (!state) return;
  
  try {
    // Check if game hasn't started yet
    if (!state.gameStarted) {
      console.log(`üéÆ Game not started yet - calling startGame()`);
      
      // Execute startGame transaction
      const result = await executeStartGame(battleId);
      
      if (result.success) {
        console.log(`‚úÖ Game started for battle ${battleId}`);
        
        // Set timer for first battle round (40 seconds)
        state.timeRemaining = 40;
        state.totalTime = 40;
        state.lastUpdate = Date.now();
        state.lastTransactionHash = result.hash;
        gameStates.set(battleId, state);
      } else {
        console.error(`‚ùå Failed to start game: ${result.error}`);
        state.gameState = 'paused';
        state.pauseReason = `Failed to start game: ${result.error}`;
        gameStates.set(battleId, state);
        stopTimer(battleId);
      }
    } 
    // Game is already started, execute battle round
    else {
      console.log(`‚öîÔ∏è Executing battle round ${state.currentRound}`);
      
      // Execute battle transaction
      const result = await executeBattle(battleId);
      
      if (result.success) {
        console.log(`‚úÖ Battle round ${state.currentRound} completed`);
        
        // Increment round and reset timer
        state.currentRound += 1;
        state.lastTransactionHash = result.hash;
        
        // Check if game is complete
        if (state.currentRound > state.totalRounds) {
          console.log(`üèÅ Battle ${battleId} completed after ${state.totalRounds} rounds`);
          state.gameState = 'finished';
          state.timeRemaining = 0;
          gameStates.set(battleId, state);
          stopTimer(battleId);
        } else {
          // Set timer for next round (40 seconds)
          state.timeRemaining = 40;
          state.totalTime = 40;
          state.lastUpdate = Date.now();
          gameStates.set(battleId, state);
        }
      } else {
        console.error(`‚ùå Failed to execute battle: ${result.error}`);
        state.gameState = 'paused';
        state.pauseReason = `Failed to execute battle: ${result.error}`;
        gameStates.set(battleId, state);
        stopTimer(battleId);
      }
    }
  } catch (error) {
    console.error(`‚ùå Error handling timer expiration:`, error);
    state.gameState = 'paused';
    state.pauseReason = `Error: ${error instanceof Error ? error.message : 'Unknown error'}`;
    gameStates.set(battleId, state);
    stopTimer(battleId);
  }
}

// Clean up battle resources
function cleanupBattle(battleId: string) {
  stopTimer(battleId);
  gameStates.delete(battleId);
  arenaAddressCache.delete(battleId);
  lastTransactionHashes.delete(battleId);
  console.log(`üßπ Cleaned up battle ${battleId}`);
}

// API handler
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { battleId } = req.query;

  if (!battleId || typeof battleId !== 'string') {
    return res.status(400).json({ error: 'Battle ID is required' });
  }

  try {
    switch (req.method) {
      case 'GET':
        // Return current game state
        const gameState = gameStates.get(battleId);
        if (!gameState) {
          return res.status(404).json({ error: 'Battle not found' });
        }
        
        return res.status(200).json({
          ...gameState,
          hasActiveTimer: activeTimers.has(battleId)
        });

      case 'POST':
        const { action, yodha1Id, yodha2Id } = req.body;

        switch (action) {
          case 'initialize':
            // Initialize new battle
            console.log(`üéÆ Initializing battle ${battleId}`);
            
            const newGameState = {
              battleId,
              gameState: 'active',
              timeRemaining: 70,  // 70 seconds for initial timer
              totalTime: 70,
              lastUpdate: Date.now(),
              currentRound: 1,
              totalRounds: 5,
              isSimulation: battleId.toString().startsWith('sim'),
              yodha1Id: yodha1Id || 1,
              yodha2Id: yodha2Id || 2,
              gameStarted: false,  // Start with game not started
              automationEnabled: true
            };

            gameStates.set(battleId, newGameState);
            
            // Start timer (1 second intervals)
            startTimer(battleId);
            
            console.log(`‚úÖ Battle ${battleId} initialized with 70s initial timer`);
            
            return res.status(200).json({
              ...newGameState,
              message: 'Battle initialized with automatic execution (70s timer)'
            });

          case 'pause':
            // Pause automation
            const pauseState = gameStates.get(battleId);
            if (!pauseState) {
              return res.status(404).json({ error: 'Battle not found' });
            }

            stopTimer(battleId);
            pauseState.gameState = 'paused';
            pauseState.pauseReason = 'Manually paused';
            gameStates.set(battleId, pauseState);

            console.log(`‚è∏Ô∏è Paused battle ${battleId}`);
            
            return res.status(200).json({
              message: 'Battle paused',
              state: pauseState
            });

          case 'resume':
            // Resume automation
            const resumeState = gameStates.get(battleId);
            if (!resumeState) {
              return res.status(404).json({ error: 'Battle not found' });
            }

            resumeState.gameState = 'active';
            resumeState.pauseReason = null;
            
            // Set appropriate timer based on game state
            if (!resumeState.gameStarted) {
              // If game not started, set initial timer
              resumeState.timeRemaining = 70;
              resumeState.totalTime = 70;
            } else {
              // For subsequent rounds
              resumeState.timeRemaining = 40;
              resumeState.totalTime = 40;
            }
            
            resumeState.lastUpdate = Date.now();
            gameStates.set(battleId, resumeState);
            
            // Restart timer
            startTimer(battleId);

            console.log(`‚ñ∂Ô∏è Resumed battle ${battleId}`);
            
            return res.status(200).json({
              message: 'Battle resumed',
              state: resumeState
            });

          case 'cleanup':
            // Clean up resources
            cleanupBattle(battleId);
            
            return res.status(200).json({
              message: 'Battle cleaned up successfully'
            });

          default:
            return res.status(400).json({ error: 'Invalid action' });
        }

      default:
        res.setHeader('Allow', ['GET', 'POST']);
        return res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Arena API error:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
