import { NextApiRequest, NextApiResponse } from 'next';
import { createWalletClient, http, createPublicClient, keccak256, encodePacked } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { defineChain } from 'viem';
import { KurukshetraAbi } from '../../../constants';

// Define Flow EVM chains
const flowTestnet = defineChain({
  id: 545,
  name: 'Flow Testnet',
  network: 'flow-testnet',
  nativeCurrency: { decimals: 18, name: 'Flow', symbol: 'FLOW' },
  rpcUrls: {
    default: { http: ['https://testnet.evm.nodes.onflow.org'] },
    public: { http: ['https://testnet.evm.nodes.onflow.org'] }
  },
  blockExplorers: {
    default: { name: 'Flow Testnet Explorer', url: 'https://evm-testnet.flowscan.org' }
  }
});

// Game state storage and timers
const gameStates = new Map<string, any>();
const activeTimers = new Map<string, NodeJS.Timeout>();

// Initialize blockchain clients
function initializeClients() {
  const gameMasterPrivateKey = process.env.NEXT_PUBLIC_GAME_MASTER_PRIVATE_KEY;
  
  const publicClient = createPublicClient({
    chain: flowTestnet,
    transport: http('https://testnet.evm.nodes.onflow.org')
  });

  if (!gameMasterPrivateKey) {
    console.warn('Game master private key not found - using simulation mode');
    return { walletClient: null, publicClient };
  }

  const gameMasterAccount = privateKeyToAccount(
    gameMasterPrivateKey.startsWith('0x') 
      ? gameMasterPrivateKey as `0x${string}`
      : `0x${gameMasterPrivateKey}` as `0x${string}`
  );

  const walletClient = createWalletClient({
    account: gameMasterAccount,
    chain: flowTestnet,
    transport: http('https://testnet.evm.nodes.onflow.org')
  });

  return { walletClient, publicClient };
}

// FIXED signature generation function
async function createBattleSignature(move1: number, move2: number, walletClient: any): Promise<string> {
  // Create the correct signature format that matches the contract expectations
  const encodedMoves = encodePacked(['uint8', 'uint8'], [move1, move2]);
  const dataHash = keccak256(encodedMoves);
  const ethSignedMessageHash = keccak256(
    encodePacked(['string', 'bytes32'], ['\x19Ethereum Signed Message:\n32', dataHash])
  );
  
  if (!walletClient) {
    // Return mock signature for simulation
    return ethSignedMessageHash;
  }
  
  // Sign with actual wallet
  const signature = await walletClient.signMessage({
    message: { raw: ethSignedMessageHash }
  });
  
  return signature;
}

// Verify that the last transaction was successful
async function verifyLastTransaction(battleId: string, lastTxHash: string): Promise<boolean> {
  if (!lastTxHash || lastTxHash.startsWith('sim-')) {
    // Simulation mode - always consider successful
    return true;
  }

  try {
    const { publicClient } = initializeClients();
    if (!publicClient) return false;

    console.log(`üîç Verifying transaction ${lastTxHash}...`);
    
    const receipt = await publicClient.getTransactionReceipt({
      hash: lastTxHash as `0x${string}`
    });

    if (receipt.status === 'success') {
      console.log(`‚úÖ Last transaction ${lastTxHash} was successful`);
      return true;
    } else {
      console.error(`‚ùå Last transaction ${lastTxHash} failed with status: ${receipt.status}`);
      return false;
    }
  } catch (error) {
    console.error(`‚ùå Failed to verify transaction ${lastTxHash}:`, error);
    return false;
  }
}

// Auto execute next round with correct signature and transaction verification
async function autoExecuteNextRound(battleId: string) {
  console.log(`ü§ñ AUTO-EXECUTING: Next round for battle ${battleId}`);
  
  const state = gameStates.get(battleId);
  if (!state) {
    console.error('‚ùå Game state not found');
    return { success: false, error: 'Game state not found' };
  }

  // Verify last transaction was successful before proceeding (except for first round)
  if (state.currentRound > 1 && state.lastTransactionHash) {
    console.log(`üîç Verifying last transaction before proceeding...`);
    const lastTxSuccessful = await verifyLastTransaction(battleId, state.lastTransactionHash);
    
    if (!lastTxSuccessful) {
      console.error(`‚ùå Last transaction failed - cannot proceed to next round`);
      return { 
        success: false, 
        error: 'Previous transaction failed - manual intervention required',
        requiresManualCheck: true
      };
    }
    
    console.log(`‚úÖ Previous transaction verified - proceeding with next round`);
  }

  try {
    // Generate AI moves (placeholder - would normally call NEAR AI)
    const move1 = Math.floor(Math.random() * 5);
    const move2 = Math.floor(Math.random() * 5);
    
    console.log(`üéØ AI selected moves: ${move1} vs ${move2}`);
    
    const { walletClient, publicClient } = initializeClients();
    
    // Create correct signature
    const signature = await createBattleSignature(move1, move2, walletClient);
    
    if (walletClient && battleId.startsWith('0x')) {
      // Real blockchain transaction
      console.log(`üöÄ Executing battle on contract ${battleId}`);
      
      const hash = await walletClient.writeContract({
        address: battleId as `0x${string}`,
        abi: KurukshetraAbi,
        functionName: 'battle',
        args: [move1, move2, signature]
      });
      
      console.log(`‚úÖ Battle transaction sent: ${hash}`);
      console.log(`‚è≥ Waiting for transaction confirmation...`);
      
      const receipt = await publicClient.waitForTransactionReceipt({
        hash: hash as `0x${string}`,
        timeout: 60000
      });
      
      if (receipt.status === 'success') {
        console.log(`‚úÖ Transaction confirmed successfully in block ${receipt.blockNumber}`);
        
        return {
          success: true,
          hash,
          moves: { move1, move2 },
          signature: signature.slice(0, 10) + '...',
          blockNumber: receipt.blockNumber,
          verified: true
        };
      } else {
        console.error(`‚ùå Transaction failed with status: ${receipt.status}`);
        return {
          success: false,
          error: `Transaction failed with status: ${receipt.status}`,
          hash,
          requiresManualCheck: true
        };
      }
    } else {
      // Simulation mode
      console.log(`‚öîÔ∏è Simulating battle execution`);
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      return {
        success: true,
        hash: `sim-battle-${Date.now()}`,
        moves: { move1, move2 },
        signature: signature.slice(0, 10) + '...',
        simulation: true,
        verified: true
      };
    }
  } catch (error) {
    console.error(`‚ùå Failed to execute next round:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      requiresManualCheck: true
    };
  }
}

// Start automatic round timer with transaction verification
function startAutoRoundTimer(battleId: string) {
  // Clear any existing timer
  const existingTimer = activeTimers.get(battleId);
  if (existingTimer) {
    clearInterval(existingTimer);
  }

  const timer = setInterval(async () => {
    const state = gameStates.get(battleId);
    if (!state || state.gameState !== 'playing') {
      clearInterval(timer);
      activeTimers.delete(battleId);
      return;
    }

    // Update countdown
    state.timeRemaining = Math.max(0, state.timeRemaining - 1);
    state.lastUpdate = Date.now();

    console.log(`‚è∞ Round timer for ${battleId}: ${state.timeRemaining}s remaining (Round ${state.currentRound})`);

    if (state.timeRemaining <= 0) {
      console.log(`‚öîÔ∏è Time expired! Auto-executing round ${state.currentRound}...`);
      
      const result = await autoExecuteNextRound(battleId);
      
      if (result.success) {
        console.log(`‚úÖ Round ${state.currentRound} completed automatically`);
        state.currentRound += 1;
        state.timeRemaining = 40; // Reset for next round (40 seconds between rounds)
        state.totalTime = 40;
        state.lastTransactionHash = result.hash;
        state.lastMoves = result.moves;
        state.lastVerified = result.verified;
        
        // Check if battle should end
        if (state.currentRound >= 5) {
          console.log(`üèÅ Battle ${battleId} completed after 5 rounds`);
          state.gameState = 'finished';
          state.timeRemaining = 0;
          clearInterval(timer);
          activeTimers.delete(battleId);
        }
      } else {
        console.error(`‚ùå Auto-execution failed: ${result.error}`);
        state.automationError = result.error;
        
        if (result.requiresManualCheck) {
          console.warn(`‚ö†Ô∏è Manual intervention required for battle ${battleId}`);
          state.gameState = 'paused';
          state.requiresManualCheck = true;
          clearInterval(timer);
          activeTimers.delete(battleId);
        } else {
          // Reset timer to retry
          state.timeRemaining = 40;
        }
      }
    }

    gameStates.set(battleId, state);
  }, 1000);

  activeTimers.set(battleId, timer);
  console.log(`‚öîÔ∏è Auto round timer started for battle ${battleId} with transaction verification`);
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { battleId } = req.query;

  if (!battleId || typeof battleId !== 'string') {
    return res.status(400).json({ error: 'Battle ID is required' });
  }

  try {
    switch (req.method) {
      case 'GET':
        // Return current game state
        const gameState = gameStates.get(battleId);
        if (!gameState) {
          return res.status(404).json({ error: 'Battle not found' });
        }
        return res.status(200).json(gameState);

      case 'POST':
        const { action, yodha1Id, yodha2Id } = req.body;

        switch (action) {
          case 'initialize':
            console.log(`üéÆ Initializing automated battle ${battleId}`);
            
            const newGameState = {
              battleId,
              gameState: 'playing', // Start directly in playing state for automation
              timeRemaining: 70, // 70 seconds for initial round
              totalTime: 70,
              lastUpdate: Date.now(),
              currentRound: 1,
              totalRounds: 5,
              isSimulation: !battleId.startsWith('0x'),
              yodha1Id,
              yodha2Id,
              automationEnabled: true,
              transactionVerificationEnabled: true
            };

            gameStates.set(battleId, newGameState);
            
            // Start automatic round timer with verification
            startAutoRoundTimer(battleId);
            
            console.log(`‚úÖ Battle ${battleId} initialized with auto-execution and transaction verification`);
            console.log(`ÔøΩÔøΩ Round timer started - next round will auto-execute in 30s`);
            
            return res.status(200).json({
              ...newGameState,
              message: 'Battle initialized with automatic round execution and transaction verification',
              signatureFixed: true,
              transactionVerification: true
            });

          case 'cleanup':
            // Stop automation and clean up
            const timer = activeTimers.get(battleId);
            if (timer) {
              clearInterval(timer);
              activeTimers.delete(battleId);
            }
            gameStates.delete(battleId);
            console.log(`üßπ Cleaned up automation for battle ${battleId}`);
            
            return res.status(200).json({ message: 'Battle automation cleaned up' });

          case 'resume':
            // Resume paused battle after manual intervention
            const pausedState = gameStates.get(battleId);
            if (pausedState && pausedState.gameState === 'paused') {
              pausedState.gameState = 'playing';
              pausedState.requiresManualCheck = false;
              pausedState.automationError = null;
              pausedState.timeRemaining = 40;
              
              startAutoRoundTimer(battleId);
              
              console.log(`‚ñ∂Ô∏è Resumed automated battle ${battleId}`);
              return res.status(200).json({
                ...pausedState,
                message: 'Battle automation resumed'
              });
            }
            
            return res.status(400).json({ error: 'Battle is not in paused state' });

          default:
            return res.status(400).json({ error: 'Invalid action. Use "initialize", "cleanup", or "resume"' });
        }

      default:
        res.setHeader('Allow', ['GET', 'POST']);
        return res.status(405).end(`Method ${req.method} Not Allowed`);
    }
  } catch (error) {
    console.error('Arena automation error:', error);
    return res.status(500).json({
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}
